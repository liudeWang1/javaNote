## JVM内存结构
分为5个部分：   
### 程序计算器
#### 定义
程序计算器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此程序计算器为Undefined。
#### 作用
+ 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
+ 在多线程的情况下，程序计算器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。
#### 特点
+ 是一块较小的内存空间；
+ 线程私有；
+ 生命周期随着线程创建而创建，随着线程销毁而销毁；
+ 是唯一一个不会出现OutOfMemoryError的内存区域。
### Java虚拟机栈
#### 定义
Java虚拟机栈是描述Java方法运行过程的内存模型。   
Java虚拟机会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：   
+ 局部变量表
+ 操作数栈
+ 动态链接
+ 方法出口信息
+ ...
#### 入栈出栈过程
当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。   
Java虚拟机的栈顶的栈帧时当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另外一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变成当前的活动栈帧。  
方法结束后，当前栈帧被移除，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧操作数中操作数没有变化。   
**Java虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。**   
#### 特点
+ 局部变量表随着栈帧的创建而创建，他的大小在编译时确定，创建时只用分配事先规定的大小即可，在方法运行过程中，局部变量表的大小不会发生改变。   
+ Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。
  - StackOverFlowError若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，抛出StackOverFlowError异常。
  - OutOfMemoryError是若当前虚拟机栈允许动态扩展，那么当线程请求栈的内存用完了，无法再动态扩展时，抛出OutOfMemoryError异常。   
+ Java虚拟机栈也是线程私有的，随着线程创建而创建，随着线程结束而销毁。   
**出现StackOverFlowError时，内存空间可能还有很多。**   
### 本地方法栈
#### 定义
本地方法栈时JVM运行Native方法准备的空间，由于许多Native方法都是由C语言编写的，所以又叫C栈，它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。   
#### 栈帧变化过程  
本地方法被执行时，在本地方法栈也会创建一块栈帧，用于创建该方法的局部变量表、操作数栈、动态链接、方法出口信息等。   
方法执行结束之后，相应的栈帧也会出栈，并释放内存空间。也会抛出StackOverFlowError和OutOfMemoryError异常。   
**如果Java虚拟机栈本身不支持Native方法，或是本身不依赖与传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。**   
### 堆
#### 定义
堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。
#### 特点
+ 线程共享，整个java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个；
+ 在虚拟机启动时创建；
+ 是垃圾回收的主要场所；
+ 进一步可分为： 新生代（Eden区From Survior To Survivor）、老年代。
不同区域存放不同生命周期的对象，这样可以根据不同区域使用不同的垃圾回收算法，更具有针对性。   
堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出OutOfMemoryError异常。   
**方法堆所使用的内存不用保证连续，而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性**   
### 方法区
#### 定义
Java虚拟机规范中定义·方法区是堆的一个逻辑部分，方法区存放以下信息：   
+ 已经被虚拟机加载的类信息；
+ 常量；
+ 静态变量；
+ 即时编译器编译后的代码。
#### 特点
+ 线程共享，方法区是堆的一个逻辑部分，因此和堆一样都是线程共享的，整个虚拟机中只有一个方法区。
+ 永久代，方法区中的信息一般需要长期存在，而且他又是堆的逻辑分区，因此用堆的划分方法，可以将方法区称为“永久代”。
+ 内存回收率低，方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效，主要回收目标是：对常量池的回收；对类型的卸载。
+ Java虚拟机规范对方法区的要求比较宽松，和堆一样，即允许固定大小，也允许动态扩展，还允许不实现垃圾回收。 
#### 运行时常量池
方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码，常量就存放在运行时常量池中。  
当类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中，而且在运行期间，可以向常量池中添加新的常量。如String类的intern()方法就能在运行期间向常量池中添加字符串常量。   
### 直接内存
直接内存是除Java虚拟机之外的内存，但也可能被Java使用。   
#### 操作直接内存
在NIO中引入了一种基于通道和缓存的IO方式，它可以调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无需将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。   
直接内存的大小不受Java虚拟机的限制，但既然是内存，当内存不足时就会抛出OutOfMemoryError 异常。   
#### 直接内存与堆内存比较
+ 直接内存申请空间耗费更高的性能；
+ 直接内存读取IO的性能要优于普通的堆内存；
+ 本地内存作用链： 本地IO->直接内存->本地IO；
+ 堆内存作用链： 本地IO->直接内存->非直接内存->直接内存->本地IO；   
服务器管理员在配置虚拟机参数时，会根据实际内存设置设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。